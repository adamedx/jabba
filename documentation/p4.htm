<!-- Published by Quadralay WebWorks HTML Lite 1.5 -->
<html>
<head>
<title>EECS 483: Project 4</title>
</head>

<body><h1></h1>
<hr>

<a name="95">
<h1>EECS 483<br>Winter 1996<br>Programming Project 4<br> Code Generation</h1>
</a>
<a name="97">
In the last problem, you generated prefix code with your compiler. For project 4, you will write a ``pattern matching'' code generator. It will take the prefix representation generated by a P3-like compiler and generate assembly instructions for execution on SPIM: a simulator for the MIPS R2000 architecture. A description of SPIM is available on-line. You should print a copy of this document and study it: it is your `bible' for this project.<p>
</a>
<a name="99">
For brave souls, P4 provides for additional problems giving extra credit for the project.<p>
</a>
<a name="101">
<h3><strong>Language</strong></h3>
</a>
<a name="103">
The source language for P4 is essentially the output language of P3. There are some notable exceptions, however, so you should study this document and understand the changes.<p>
</a>
<a name="105">
Modules are collections of functions:<p>
</a>
<a name="107">
	<code>module		</code>-><code> global_space function_list<br>	global_space	 </code>-><code> </code><strong>global</strong><code> INTEGER_CONSTANT<br>	function_list</code>		-> <code>function function_list<br>
	-> function</code><p>
</a>
<a name="109">
There must be at least 1 function in a module. There must be 1 function in a module called <strong>main</strong>. This is the ``entry point'' from the SPIM system.<p>
</a>
<a name="111">
The global space defines the size of the global area for the program. This must be allocated as a static constant at the beginning of the module.<p>
</a>
<a name="113">
A function has a name and a body:<p>
</a>
<a name="115">
	<code>function	</code>	-> <code>IDENT compound_stmt</code><p>
</a>
<a name="117">
The IDENT is the symbol of the function while the compound statement constitutes its body.<p>
</a>
<a name="119">
You must save registers upon entry to a function and restore registers upon return. (The end of the function is an implied <strong>return</strong>.)<p>
</a>
<a name="121">
A compound statement defines a nested scope. Its syntax is:<p>
</a>
<a name="123">
<code>	compound_stmt </code>		-> <code>`{' INTEGER_CONST stmt_list `}'</code><p>
</a>
<a name="125">
The integer constant at the beginning of the compound statement is the position of the STACK_TOP (``high_water_mark''). This changes due to variable declarations within the basic block. (This value is only of interest if one is doing extra-credit, otherwise it can be ignored.)<p>
</a>
<a name="127">
A <code>stmt_list</code> is a list of statements (<code>stmt</code>). The set of statements include:<p>
</a>
<dl><dl><a name="129">
<dt> 	compound_stmt<br><code>	</code><strong>assign</strong><code> variable expression<br>	</code><strong>while</strong><code> int_expr compound_stmt<br>	</code><strong>if</strong><code> int_expr compound_stmt<br>	</code><strong>if</strong><code> int_expr </code><strong>then</strong> <code>compound_stmt </code><strong>else</strong><code> compound_stmt<br>	</code><strong>call</strong><code> IDENT `(` INTEGER_CONST `)'<br>	</code><strong>return<br></strong><code>	</code><strong>print</strong><code> int_expr<br>	</code><strong>print</strong><code> real_expr<br>	</code><strong>print</strong><code> string			// </code>Has the form ``stuff''<br><code>	</code><strong>println</strong>
</a>
</dl></dl><a name="131">
For the call statement, the INTEGER_CONST is used to adjust the stack pointer in preparation for the call.<p>
</a>
<a name="133">
Each of the PRINT (and PRINTLN) statements map directly to SPIM operations (actually, system service requests).<p>
</a>
<a name="135">
<p>
</a>
<a name="137">
The usual set of operators are provided:<p>
</a>
<dl><dl><a name="139">
<dt> 	<code>+, *, -, /, % <br>	&lt;, &gt;, &lt;=, &gt;=, ==, !=<br>	&amp;&amp;, ||<br>	</code><strong>Uminus</strong><code>, !		</code>// Logical Complement
</a>
</dl></dl><a name="141">
From your work on P3, it should be clear that these are prefix operators. Thus, the following are examples of the prefix expressions:<p>
</a>
<dl><dl><a name="143">
<dt> 	<code>int_expr		</code>-> <code>+ int_expr int_expr<br></code><br>	<code>real_expr		</code>-><code> + real_expr real_expr</code>
</a>
</dl></dl><a name="145">
You can cast as follows:<p>
</a>
<dl><dl><a name="147">
<dt> <code>	int_expr		</code>-><code> real_expr<br><br>	real_expr		</code>-><code> int_expr</code>
</a>
</dl></dl><a name="149">
HOWEVER, you must be careful of the ordering of productions in your pattern matching grammar. As mentioned in lecture, pattern matching grammars are usually ambiguous (and can include REDUCE/REDUCE conflicts)!<p>
</a>
<a name="151">
At the ``bottom'' of the grammar, we have variables. As with the output of P3, variables have the following form:<br><br>	<code>int objectArea offset<br>	real objectArea offset<br>	big INTEGER_CONST objectArea offset</code><p>
</a>
<a name="153">
The INTEGER_CONST for <strong>big</strong> variables indicates the number of bytes to be moved. This value can be rounded UP to the next integral multiple of 4.<p>
</a>
<a name="155">
The following objectAreas are supported:<p>
</a>
<dl><dl><a name="157">
<dt> 	<code>local<br></code>	<code>global<br></code>	<code>pointer</code>		// Only supports an INT_EXPR for offset<br>	<code>temp</code>		// Reference to temporary; only INT_CONST.<br>	<code>param		</code>// Reference to Param area.
</a>
</dl></dl><a name="159">
Except for pointer and temp references, an offset can either be an <code>INTEGER_CONST</code> or an <code>int_expr</code>.<p>
</a>
<a name="161">
<h3>Requirements</h3>
</a>
<a name="163">
You will need to demonstrate your compiler in a 15 to 30 minute session with me.<p>
</a>
<a name="165">
All projects should be completed and demonstrated no later than Friday April 26th (you do have exams in other classes, you know).<p>
</a>
<a name="167">
<h3>Extra Credit</h3>
</a>
<a name="169">
If you complete the base assignment, there are plenty of opportunities for extra credit. Topics include:<p>
</a>

<dl>
<a name="192">
<dt>o	 Function calls in expressions. This will use the constant in the compound statement to determine the STACK_TOP, then allocate temporaries for expression evaluation for the function call as required. This will require the productions:<br>
</a>
<dl>
<a name="213">
<dt> 	<code>expr_list	</code>-><code> expr_list `,' expr<br>		-> expr <br></code>
</a>
<a name="218">
<dt> <code>		int_expr	</code>-><code>	int_callIDENT `(` expr_list `)'<br></code>
</a>
<a name="215">
<dt> <code>		real_expr	</code>-><code>	real_call IDENT `(` expr_list `)'</code>
</a>
</dl>
<a name="173">
<dt>o	 Register Spilling. This will be tested using a #pragma to reduce the number of registers available for evaluation.
</a>
<a name="175">
<dt>o	 Scheduling for the processor's execution pipeline. This requires a ``peephole'' pass over the generated code to schedule the instructions to minimize pipeline hazards.
</a>
<a name="177">
<dt>o	 global register allocation for scalars (using <strong>use counts</strong> or <strong>coloring</strong>)
</a>

</dl>
<a name="179">
See me before you embark on an extra credit project.<p>
</a>

<p><hr>

<h5>Last Modified: 02:26pm EDT, April 18, 1996</h5>
</body>
</html>
